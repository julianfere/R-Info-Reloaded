import {
  JisonParser,
  JisonParserApi,
  StateType,
  SymbolsType,
  TerminalsType,
  ProductionsType,
} from "@ts-jison/parser";
/**
 * parser generated by  @ts-jison/parser-generator 0.4.1-alpha.2
 * @returns Parser implementing JisonParserApi and a Lexer implementing JisonLexerApi.
 */
export class RinfoParser extends JisonParser implements JisonParserApi {
  $?: any;
  symbols_: SymbolsType = {
    error: 2,
    programa: 3,
    PROGRAMA: 4,
    ID: 5,
    secciones: 6,
    FIN: 7,
    seccion: 8,
    AREAS: 9,
    area_defs: 10,
    ROBOTS: 11,
    robot_defs: 12,
    VARIABLES: 13,
    var_defs: 14,
    COMENZAR: 15,
    acciones: 16,
    area_def: 17,
    ":": 18,
    AREAC: 19,
    AREAP: 20,
    AREAPC: 21,
    "(": 22,
    NUMBER: 23,
    ",": 24,
    ")": 25,
    robot_def: 26,
    ROBOT: 27,
    var_def: 28,
    numero: 29,
    boolean: 30,
    accion: 31,
    repetir: 32,
    veces: 33,
    finrepetir: 34,
    mover: 35,
    derecha: 36,
    si: 37,
    condicion: 38,
    finsi: 39,
    AsignarArea: 40,
    Iniciar: 41,
    "==": 42,
    "!=": 43,
    "<": 44,
    ">": 45,
    $accept: 0,
    $end: 1,
  };
  terminals_: TerminalsType = {
    2: "error",
    4: "PROGRAMA",
    5: "ID",
    7: "FIN",
    9: "AREAS",
    11: "ROBOTS",
    13: "VARIABLES",
    15: "COMENZAR",
    18: ":",
    19: "AREAC",
    20: "AREAP",
    21: "AREAPC",
    22: "(",
    23: "NUMBER",
    24: ",",
    25: ")",
    27: "ROBOT",
    29: "numero",
    30: "boolean",
    32: "repetir",
    33: "veces",
    34: "finrepetir",
    35: "mover",
    36: "derecha",
    37: "si",
    39: "finsi",
    40: "AsignarArea",
    41: "Iniciar",
    42: "==",
    43: "!=",
    44: "<",
    45: ">",
  };
  productions_: ProductionsType = [
    0,
    [3, 4],
    [6, 1],
    [6, 2],
    [8, 2],
    [8, 2],
    [8, 2],
    [8, 3],
    [10, 1],
    [10, 2],
    [17, 3],
    [17, 1],
    [17, 10],
    [12, 1],
    [12, 2],
    [26, 5],
    [14, 1],
    [14, 2],
    [28, 3],
    [28, 1],
    [16, 1],
    [16, 2],
    [31, 5],
    [31, 1],
    [31, 1],
    [31, 6],
    [31, 6],
    [31, 8],
    [38, 3],
    [38, 3],
    [38, 3],
    [38, 3],
  ];
  table: Array<StateType>;
  defaultActions: { [key: number]: any } = {
    10: [2, 1],
    68: [2, 28],
    69: [2, 29],
    70: [2, 30],
    71: [2, 31],
  };

  constructor(yy = {}, lexer = new RinfoLexer(yy)) {
    super(yy, lexer);

    // shorten static method to just `o` for terse STATE_TABLE
    const $V0 = [1, 6],
      $V1 = [1, 7],
      $V2 = [1, 8],
      $V3 = [1, 9],
      $V4 = [7, 9, 11, 13, 15],
      $V5 = [1, 14],
      $V6 = [1, 15],
      $V7 = [1, 16],
      $V8 = [1, 19],
      $V9 = [1, 22],
      $Va = [1, 23],
      $Vb = [1, 26],
      $Vc = [1, 27],
      $Vd = [1, 28],
      $Ve = [1, 29],
      $Vf = [1, 30],
      $Vg = [1, 31],
      $Vh = [5, 7, 9, 11, 13, 15, 20, 21],
      $Vi = [7, 9, 11, 13, 15, 27],
      $Vj = [5, 7, 9, 11, 13, 15, 30],
      $Vk = [7, 32, 34, 35, 36, 37, 39, 40, 41];
    const o = JisonParser.expandParseTable;
    this.table = [
      { 3: 1, 4: [1, 2] },
      { 1: [3] },
      { 5: [1, 3] },
      { 6: 4, 8: 5, 9: $V0, 11: $V1, 13: $V2, 15: $V3 },
      { 7: [1, 10], 8: 11, 9: $V0, 11: $V1, 13: $V2, 15: $V3 },
      o($V4, [2, 2]),
      { 5: $V5, 10: 12, 17: 13, 20: $V6, 21: $V7 },
      { 12: 17, 26: 18, 27: $V8 },
      { 5: $V9, 14: 20, 28: 21, 30: $Va },
      { 16: 24, 31: 25, 32: $Vb, 35: $Vc, 36: $Vd, 37: $Ve, 40: $Vf, 41: $Vg },
      { 1: [2, 1] },
      o($V4, [2, 3]),
      o($V4, [2, 4], { 17: 32, 5: $V5, 20: $V6, 21: $V7 }),
      o($Vh, [2, 8]),
      { 18: [1, 33] },
      o($Vh, [2, 11]),
      { 22: [1, 34] },
      o($V4, [2, 5], { 26: 35, 27: $V8 }),
      o($Vi, [2, 13]),
      { 5: [1, 36] },
      o($V4, [2, 6], { 28: 37, 5: $V9, 30: $Va }),
      o($Vj, [2, 16]),
      { 18: [1, 38] },
      o($Vj, [2, 19]),
      {
        7: [1, 39],
        31: 40,
        32: $Vb,
        35: $Vc,
        36: $Vd,
        37: $Ve,
        40: $Vf,
        41: $Vg,
      },
      o($Vk, [2, 20]),
      { 23: [1, 41] },
      o($Vk, [2, 23]),
      o($Vk, [2, 24]),
      { 22: [1, 42] },
      { 22: [1, 43] },
      { 22: [1, 44] },
      o($Vh, [2, 9]),
      { 19: [1, 45] },
      { 23: [1, 46] },
      o($Vi, [2, 14]),
      { 15: [1, 47] },
      o($Vj, [2, 17]),
      { 29: [1, 48] },
      o($V4, [2, 7]),
      o($Vk, [2, 21]),
      { 33: [1, 49] },
      { 5: [1, 51], 38: 50 },
      { 5: [1, 52] },
      { 5: [1, 53] },
      o($Vh, [2, 10]),
      { 24: [1, 54] },
      { 16: 55, 31: 25, 32: $Vb, 35: $Vc, 36: $Vd, 37: $Ve, 40: $Vf, 41: $Vg },
      o($Vj, [2, 18]),
      { 16: 56, 31: 25, 32: $Vb, 35: $Vc, 36: $Vd, 37: $Ve, 40: $Vf, 41: $Vg },
      { 25: [1, 57] },
      { 42: [1, 58], 43: [1, 59], 44: [1, 60], 45: [1, 61] },
      { 24: [1, 62] },
      { 24: [1, 63] },
      { 23: [1, 64] },
      {
        7: [1, 65],
        31: 40,
        32: $Vb,
        35: $Vc,
        36: $Vd,
        37: $Ve,
        40: $Vf,
        41: $Vg,
      },
      {
        31: 40,
        32: $Vb,
        34: [1, 66],
        35: $Vc,
        36: $Vd,
        37: $Ve,
        40: $Vf,
        41: $Vg,
      },
      { 16: 67, 31: 25, 32: $Vb, 35: $Vc, 36: $Vd, 37: $Ve, 40: $Vf, 41: $Vg },
      { 23: [1, 68] },
      { 23: [1, 69] },
      { 23: [1, 70] },
      { 23: [1, 71] },
      { 5: [1, 72] },
      { 23: [1, 73] },
      { 24: [1, 74] },
      o($Vi, [2, 15]),
      o($Vk, [2, 22]),
      {
        31: 40,
        32: $Vb,
        35: $Vc,
        36: $Vd,
        37: $Ve,
        39: [1, 75],
        40: $Vf,
        41: $Vg,
      },
      { 25: [2, 28] },
      { 25: [2, 29] },
      { 25: [2, 30] },
      { 25: [2, 31] },
      { 25: [1, 76] },
      { 24: [1, 77] },
      { 23: [1, 78] },
      o($Vk, [2, 25]),
      o($Vk, [2, 26]),
      { 23: [1, 79] },
      { 24: [1, 80] },
      { 25: [1, 81] },
      { 23: [1, 82] },
      o($Vk, [2, 27]),
      { 25: [1, 83] },
      o($Vh, [2, 12]),
    ];
  }

  performAction(
    yytext: string,
    yyleng: number,
    yylineno: number,
    yy: any,
    yystate: number /* action[1] */,
    $$: any /* vstack */,
    _$: any /* lstack */
  ): any {
    /* this == yyval */
    var $0 = $$.length - 1;
    switch (yystate) {
    }
  }
}

/* generated by @ts-jison/lexer-generator 0.4.1-alpha.2 */
import { JisonLexer, JisonLexerApi } from "@ts-jison/lexer";

export class RinfoLexer extends JisonLexer implements JisonLexerApi {
  options: any = { moduleName: "TsCalc" };
  constructor(yy = {}) {
    super(yy);
  }

  rules: RegExp[] = [
    /^(?:\s+)/,
    /^(?:programa\b)/,
    /^(?:areas\b)/,
    /^(?:robots\b)/,
    /^(?:variables\b)/,
    /^(?:comenzar\b)/,
    /^(?:fin\b)/,
    /^(?:AreaC\b)/,
    /^(?:AreaP\b)/,
    /^(?:AreaPC\b)/,
    /^(?:[0-9]+)/,
    /^(?:[a-zA-Z][a-zA-Z0-9])/,
    /^(?::=)/,
    /^(?:[()])/,
    /^(?:$)/,
    /^(?:.)/,
  ];
  conditions: any = {
    INITIAL: {
      rules: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15],
      inclusive: true,
    },
  };
  performAction(
    yy: any,
    yy_: any,
    $avoiding_name_collisions: any,
    YY_START: any
  ): any {
    var YYSTATE = YY_START;
    switch ($avoiding_name_collisions) {
      case 0:
        / skip whitespace /;
        break;
      case 1:
        return 4;
        break;
      case 2:
        return 9;
        break;
      case 3:
        return 11;
        break;
      case 4:
        return 13;
        break;
      case 5:
        return 15;
        break;
      case 6:
        return 7;
        break;
      case 7:
        return 19;
        break;
      case 8:
        return 20;
        break;
      case 9:
        return 21;
        break;
      case 10:
        return 23;
        break;
      case 11:
        return 5;
        break;
      case 12:
        return "ASSIGN";
        break;
      case 13:
        return yy_.yytext;
        break;
      case 14:
        return "EOF";
        break;
      case 15:
        return yy_.yytext;
        break;
    }
  }
}
